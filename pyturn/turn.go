/*
cgo stubs for package turn.
File is generated by gopy. Do not edit.
gopy build --output=pyturn -vm=python3 .
*/

package main

/*

#cgo CFLAGS: -I/Library/Frameworks/Python.framework/Versions/3.11/include/python3.11 -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -L/Library/Frameworks/Python.framework/Versions/3.11/lib -lpython3.11 -ldl  -framework CoreFoundation

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"io"
	"net"
	"net/netip"
	"time"

	"github.com/pion/logging"
	"github.com/pion/randutil"
	stun "github.com/pion/stun/v3"
	transport "github.com/pion/transport/v3"
	turn "github.com/pion/turn/v4"
	"github.com/pion/turn/v4/internal/client"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: turn below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *stun.Message
func ptrFromHandle_Ptr_stun_Message(h CGoHandle) *stun.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*stun.Message")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(stun.Message{})).(*stun.Message)
}
func handleFromPtr_Ptr_stun_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*stun.Message", p))
}

// Converters for pointer handles for type: *client.TCPAllocation
func ptrFromHandle_Ptr_client_TCPAllocation(h CGoHandle) *client.TCPAllocation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.TCPAllocation")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TCPAllocation{})).(*client.TCPAllocation)
}
func handleFromPtr_Ptr_client_TCPAllocation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.TCPAllocation", p))
}

// Converters for pointer handles for type: *client.TCPConn
func ptrFromHandle_Ptr_client_TCPConn(h CGoHandle) *client.TCPConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*client.TCPConn")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TCPConn{})).(*client.TCPConn)
}
func handleFromPtr_Ptr_client_TCPConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*client.TCPConn", p))
}

// Converters for pointer handles for type: *net.TCPAddr
func ptrFromHandle_Ptr_net_TCPAddr(h CGoHandle) *net.TCPAddr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*net.TCPAddr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.TCPAddr{})).(*net.TCPAddr)
}
func handleFromPtr_Ptr_net_TCPAddr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*net.TCPAddr", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: logging.LoggerFactory
func ptrFromHandle_logging_LoggerFactory(h CGoHandle) logging.LoggerFactory {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "logging.LoggerFactory")
	if p == nil {
		return nil
	}
	return p.(logging.LoggerFactory)
}
func handleFromPtr_logging_LoggerFactory(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("logging.LoggerFactory", p))
}

// Converters for pointer handles for type: randutil.MathRandomGenerator
func ptrFromHandle_randutil_MathRandomGenerator(h CGoHandle) randutil.MathRandomGenerator {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "randutil.MathRandomGenerator")
	if p == nil {
		return nil
	}
	return p.(randutil.MathRandomGenerator)
}
func handleFromPtr_randutil_MathRandomGenerator(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("randutil.MathRandomGenerator", p))
}

// Converters for implicit pointer handles for type: stun.Attributes
func ptrFromHandle_stun_Attributes(h CGoHandle) *stun.Attributes {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Attributes")
	if p == nil {
		return nil
	}
	return p.(*stun.Attributes)
}
func deptrFromHandle_stun_Attributes(h CGoHandle) stun.Attributes {
	p := ptrFromHandle_stun_Attributes(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_stun_Attributes(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Attributes", p))
}

// --- wrapping slice: stun.Attributes ---
//
//export stun_Attributes_CTor
func stun_Attributes_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_stun_Attributes(&stun.Attributes{}))
}

//export stun_Attributes_len
func stun_Attributes_len(handle CGoHandle) int {
	return len(deptrFromHandle_stun_Attributes(handle))
}

//export stun_Attributes_elem
func stun_Attributes_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_stun_Attributes(handle)
	return handleFromPtr_stun_RawAttribute(&(s[_idx]))
}

//export stun_Attributes_subslice
func stun_Attributes_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_stun_Attributes(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_stun_Attributes(&ss))
}

//export stun_Attributes_set
func stun_Attributes_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_stun_Attributes(handle)
	s[_idx] = *ptrFromHandle_stun_RawAttribute(_vl)
}

//export stun_Attributes_append
func stun_Attributes_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_stun_Attributes(handle)
	*s = append(*s, *ptrFromHandle_stun_RawAttribute(_vl))
}

// Converters for pointer handles for type: stun.Checker
func ptrFromHandle_stun_Checker(h CGoHandle) stun.Checker {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Checker")
	if p == nil {
		return nil
	}
	return p.(stun.Checker)
}
func handleFromPtr_stun_Checker(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Checker", p))
}

// Converters for pointer handles for type: stun.Getter
func ptrFromHandle_stun_Getter(h CGoHandle) stun.Getter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Getter")
	if p == nil {
		return nil
	}
	return p.(stun.Getter)
}
func handleFromPtr_stun_Getter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Getter", p))
}

// Converters for non-pointer handles for type: stun.Message
func ptrFromHandle_stun_Message(h CGoHandle) *stun.Message {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Message")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(stun.Message{})).(*stun.Message)
}
func handleFromPtr_stun_Message(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Message", p))
}

// Converters for non-pointer handles for type: stun.MessageType
func ptrFromHandle_stun_MessageType(h CGoHandle) *stun.MessageType {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.MessageType")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(stun.MessageType{})).(*stun.MessageType)
}
func handleFromPtr_stun_MessageType(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.MessageType", p))
}

// Converters for non-pointer handles for type: stun.RawAttribute
func ptrFromHandle_stun_RawAttribute(h CGoHandle) *stun.RawAttribute {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.RawAttribute")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(stun.RawAttribute{})).(*stun.RawAttribute)
}
func handleFromPtr_stun_RawAttribute(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.RawAttribute", p))
}

// Converters for implicit pointer handles for type: stun.Realm
func ptrFromHandle_stun_Realm(h CGoHandle) *stun.Realm {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Realm")
	if p == nil {
		return nil
	}
	return p.(*stun.Realm)
}
func deptrFromHandle_stun_Realm(h CGoHandle) stun.Realm {
	p := ptrFromHandle_stun_Realm(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_stun_Realm(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Realm", p))
}

// --- wrapping slice: stun.Realm ---
//
//export stun_Realm_CTor
func stun_Realm_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_stun_Realm(&stun.Realm{}))
}

//export stun_Realm_len
func stun_Realm_len(handle CGoHandle) int {
	return len(deptrFromHandle_stun_Realm(handle))
}

//export stun_Realm_elem
func stun_Realm_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_stun_Realm(handle)
	return C.char(s[_idx])
}

//export stun_Realm_subslice
func stun_Realm_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_stun_Realm(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_stun_Realm(&ss))
}

//export stun_Realm_set
func stun_Realm_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_stun_Realm(handle)
	s[_idx] = byte(_vl)
}

//export stun_Realm_append
func stun_Realm_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_stun_Realm(handle)
	*s = append(*s, byte(_vl))
}

// Converters for pointer handles for type: stun.Setter
func ptrFromHandle_stun_Setter(h CGoHandle) stun.Setter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Setter")
	if p == nil {
		return nil
	}
	return p.(stun.Setter)
}
func handleFromPtr_stun_Setter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Setter", p))
}

// Converters for implicit pointer handles for type: stun.Username
func ptrFromHandle_stun_Username(h CGoHandle) *stun.Username {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "stun.Username")
	if p == nil {
		return nil
	}
	return p.(*stun.Username)
}
func deptrFromHandle_stun_Username(h CGoHandle) stun.Username {
	p := ptrFromHandle_stun_Username(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_stun_Username(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("stun.Username", p))
}

// --- wrapping slice: stun.Username ---
//
//export stun_Username_CTor
func stun_Username_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_stun_Username(&stun.Username{}))
}

//export stun_Username_len
func stun_Username_len(handle CGoHandle) int {
	return len(deptrFromHandle_stun_Username(handle))
}

//export stun_Username_elem
func stun_Username_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_stun_Username(handle)
	return C.char(s[_idx])
}

//export stun_Username_subslice
func stun_Username_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_stun_Username(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_stun_Username(&ss))
}

//export stun_Username_set
func stun_Username_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_stun_Username(handle)
	s[_idx] = byte(_vl)
}

//export stun_Username_append
func stun_Username_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_stun_Username(handle)
	*s = append(*s, byte(_vl))
}

// Converters for pointer handles for type: transport.Net
func ptrFromHandle_transport_Net(h CGoHandle) transport.Net {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.Net")
	if p == nil {
		return nil
	}
	return p.(transport.Net)
}
func handleFromPtr_transport_Net(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.Net", p))
}

// Converters for pointer handles for type: transport.TCPConn
func ptrFromHandle_transport_TCPConn(h CGoHandle) transport.TCPConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "transport.TCPConn")
	if p == nil {
		return nil
	}
	return p.(transport.TCPConn)
}
func handleFromPtr_transport_TCPConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("transport.TCPConn", p))
}

// Converters for non-pointer handles for type: client.TCPAllocation
func ptrFromHandle_client_TCPAllocation(h CGoHandle) *client.TCPAllocation {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.TCPAllocation")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TCPAllocation{})).(*client.TCPAllocation)
}
func handleFromPtr_client_TCPAllocation(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.TCPAllocation", p))
}

// Converters for non-pointer handles for type: client.TCPConn
func ptrFromHandle_client_TCPConn(h CGoHandle) *client.TCPConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.TCPConn")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TCPConn{})).(*client.TCPConn)
}
func handleFromPtr_client_TCPConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.TCPConn", p))
}

// Converters for non-pointer handles for type: client.TransactionResult
func ptrFromHandle_client_TransactionResult(h CGoHandle) *client.TransactionResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "client.TransactionResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(client.TransactionResult{})).(*client.TransactionResult)
}
func handleFromPtr_client_TransactionResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("client.TransactionResult", p))
}

// Converters for pointer handles for type: io.Reader
func ptrFromHandle_io_Reader(h CGoHandle) io.Reader {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Reader")
	if p == nil {
		return nil
	}
	return p.(io.Reader)
}
func handleFromPtr_io_Reader(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Reader", p))
}

// Converters for pointer handles for type: io.Writer
func ptrFromHandle_io_Writer(h CGoHandle) io.Writer {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "io.Writer")
	if p == nil {
		return nil
	}
	return p.(io.Writer)
}
func handleFromPtr_io_Writer(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("io.Writer", p))
}

// Converters for pointer handles for type: net.Addr
func ptrFromHandle_net_Addr(h CGoHandle) net.Addr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.Addr")
	if p == nil {
		return nil
	}
	return p.(net.Addr)
}
func handleFromPtr_net_Addr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.Addr", p))
}

// Converters for pointer handles for type: net.Conn
func ptrFromHandle_net_Conn(h CGoHandle) net.Conn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.Conn")
	if p == nil {
		return nil
	}
	return p.(net.Conn)
}
func handleFromPtr_net_Conn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.Conn", p))
}

// Converters for implicit pointer handles for type: net.IP
func ptrFromHandle_net_IP(h CGoHandle) *net.IP {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IP")
	if p == nil {
		return nil
	}
	return p.(*net.IP)
}
func deptrFromHandle_net_IP(h CGoHandle) net.IP {
	p := ptrFromHandle_net_IP(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IP(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IP", p))
}

// --- wrapping slice: net.IP ---
//
//export net_IP_CTor
func net_IP_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IP(&net.IP{}))
}

//export net_IP_len
func net_IP_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IP(handle))
}

//export net_IP_elem
func net_IP_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IP(handle)
	return C.char(s[_idx])
}

//export net_IP_subslice
func net_IP_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IP(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IP(&ss))
}

//export net_IP_set
func net_IP_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IP(handle)
	s[_idx] = byte(_vl)
}

//export net_IP_append
func net_IP_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IP(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: net.IPMask
func ptrFromHandle_net_IPMask(h CGoHandle) *net.IPMask {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.IPMask")
	if p == nil {
		return nil
	}
	return p.(*net.IPMask)
}
func deptrFromHandle_net_IPMask(h CGoHandle) net.IPMask {
	p := ptrFromHandle_net_IPMask(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_net_IPMask(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.IPMask", p))
}

// --- wrapping slice: net.IPMask ---
//
//export net_IPMask_CTor
func net_IPMask_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_net_IPMask(&net.IPMask{}))
}

//export net_IPMask_len
func net_IPMask_len(handle CGoHandle) int {
	return len(deptrFromHandle_net_IPMask(handle))
}

//export net_IPMask_elem
func net_IPMask_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_net_IPMask(handle)
	return C.char(s[_idx])
}

//export net_IPMask_subslice
func net_IPMask_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_net_IPMask(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_net_IPMask(&ss))
}

//export net_IPMask_set
func net_IPMask_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_net_IPMask(handle)
	s[_idx] = byte(_vl)
}

//export net_IPMask_append
func net_IPMask_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_net_IPMask(handle)
	*s = append(*s, byte(_vl))
}

// Converters for pointer handles for type: net.Listener
func ptrFromHandle_net_Listener(h CGoHandle) net.Listener {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.Listener")
	if p == nil {
		return nil
	}
	return p.(net.Listener)
}
func handleFromPtr_net_Listener(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.Listener", p))
}

// Converters for pointer handles for type: net.PacketConn
func ptrFromHandle_net_PacketConn(h CGoHandle) net.PacketConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.PacketConn")
	if p == nil {
		return nil
	}
	return p.(net.PacketConn)
}
func handleFromPtr_net_PacketConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.PacketConn", p))
}

// Converters for non-pointer handles for type: net.TCPAddr
func ptrFromHandle_net_TCPAddr(h CGoHandle) *net.TCPAddr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.TCPAddr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.TCPAddr{})).(*net.TCPAddr)
}
func handleFromPtr_net_TCPAddr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.TCPAddr", p))
}

// Converters for non-pointer handles for type: net.UDPAddr
func ptrFromHandle_net_UDPAddr(h CGoHandle) *net.UDPAddr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "net.UDPAddr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(net.UDPAddr{})).(*net.UDPAddr)
}
func handleFromPtr_net_UDPAddr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("net.UDPAddr", p))
}

// Converters for non-pointer handles for type: netip.Addr
func ptrFromHandle_netip_Addr(h CGoHandle) *netip.Addr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "netip.Addr")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(netip.Addr{})).(*netip.Addr)
}
func handleFromPtr_netip_Addr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("netip.Addr", p))
}

// Converters for non-pointer handles for type: netip.AddrPort
func ptrFromHandle_netip_AddrPort(h CGoHandle) *netip.AddrPort {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "netip.AddrPort")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(netip.AddrPort{})).(*netip.AddrPort)
}
func handleFromPtr_netip_AddrPort(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("netip.AddrPort", p))
}

// Converters for non-pointer handles for type: netip.Prefix
func ptrFromHandle_netip_Prefix(h CGoHandle) *netip.Prefix {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "netip.Prefix")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(netip.Prefix{})).(*netip.Prefix)
}
func handleFromPtr_netip_Prefix(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("netip.Prefix", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: turn ---

// ---- Types ---

// Converters for pointer handles for type: *turn.Client
func ptrFromHandle_Ptr_turn_Client(h CGoHandle) *turn.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.Client{})).(*turn.Client)
}
func handleFromPtr_Ptr_turn_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.Client", p))
}

// Converters for pointer handles for type: *turn.ClientConfig
func ptrFromHandle_Ptr_turn_ClientConfig(h CGoHandle) *turn.ClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.ClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ClientConfig{})).(*turn.ClientConfig)
}
func handleFromPtr_Ptr_turn_ClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.ClientConfig", p))
}

// Converters for pointer handles for type: *turn.ListenerConfig
func ptrFromHandle_Ptr_turn_ListenerConfig(h CGoHandle) *turn.ListenerConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.ListenerConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ListenerConfig{})).(*turn.ListenerConfig)
}
func handleFromPtr_Ptr_turn_ListenerConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.ListenerConfig", p))
}

// Converters for pointer handles for type: *turn.PacketConnConfig
func ptrFromHandle_Ptr_turn_PacketConnConfig(h CGoHandle) *turn.PacketConnConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.PacketConnConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.PacketConnConfig{})).(*turn.PacketConnConfig)
}
func handleFromPtr_Ptr_turn_PacketConnConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.PacketConnConfig", p))
}

// Converters for pointer handles for type: *turn.RecievedPacket
func ptrFromHandle_Ptr_turn_RecievedPacket(h CGoHandle) *turn.RecievedPacket {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.RecievedPacket")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RecievedPacket{})).(*turn.RecievedPacket)
}
func handleFromPtr_Ptr_turn_RecievedPacket(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.RecievedPacket", p))
}

// Converters for pointer handles for type: *turn.RelayAddressGeneratorNone
func ptrFromHandle_Ptr_turn_RelayAddressGeneratorNone(h CGoHandle) *turn.RelayAddressGeneratorNone {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.RelayAddressGeneratorNone")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorNone{})).(*turn.RelayAddressGeneratorNone)
}
func handleFromPtr_Ptr_turn_RelayAddressGeneratorNone(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.RelayAddressGeneratorNone", p))
}

// Converters for pointer handles for type: *turn.RelayAddressGeneratorPortRange
func ptrFromHandle_Ptr_turn_RelayAddressGeneratorPortRange(h CGoHandle) *turn.RelayAddressGeneratorPortRange {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.RelayAddressGeneratorPortRange")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorPortRange{})).(*turn.RelayAddressGeneratorPortRange)
}
func handleFromPtr_Ptr_turn_RelayAddressGeneratorPortRange(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.RelayAddressGeneratorPortRange", p))
}

// Converters for pointer handles for type: *turn.RelayAddressGeneratorStatic
func ptrFromHandle_Ptr_turn_RelayAddressGeneratorStatic(h CGoHandle) *turn.RelayAddressGeneratorStatic {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.RelayAddressGeneratorStatic")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorStatic{})).(*turn.RelayAddressGeneratorStatic)
}
func handleFromPtr_Ptr_turn_RelayAddressGeneratorStatic(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.RelayAddressGeneratorStatic", p))
}

// Converters for pointer handles for type: *turn.STUNConn
func ptrFromHandle_Ptr_turn_STUNConn(h CGoHandle) *turn.STUNConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.STUNConn")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn)
}
func handleFromPtr_Ptr_turn_STUNConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.STUNConn", p))
}

// Converters for pointer handles for type: *turn.Server
func ptrFromHandle_Ptr_turn_Server(h CGoHandle) *turn.Server {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.Server")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.Server{})).(*turn.Server)
}
func handleFromPtr_Ptr_turn_Server(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.Server", p))
}

// Converters for pointer handles for type: *turn.ServerConfig
func ptrFromHandle_Ptr_turn_ServerConfig(h CGoHandle) *turn.ServerConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*turn.ServerConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ServerConfig{})).(*turn.ServerConfig)
}
func handleFromPtr_Ptr_turn_ServerConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*turn.ServerConfig", p))
}

// Converters for implicit pointer handles for type: [12]byte
func ptrFromHandle_Array_12_byte(h CGoHandle) *[12]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[12]byte")
	if p == nil {
		return nil
	}
	return p.(*[12]byte)
}
func deptrFromHandle_Array_12_byte(h CGoHandle) [12]byte {
	p := ptrFromHandle_Array_12_byte(h)
	return *p
}
func handleFromPtr_Array_12_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[12]byte", p))
}

// --- wrapping slice: [12]byte ---
//
//export Array_12_byte_CTor
func Array_12_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_12_byte(&[12]byte{}))
}

//export Array_12_byte_len
func Array_12_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_12_byte(handle))
}

//export Array_12_byte_elem
func Array_12_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Array_12_byte(handle)
	return C.char(s[_idx])
}

//export Array_12_byte_set
func Array_12_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Array_12_byte(handle)
	s[_idx] = byte(_vl)
}

// Converters for implicit pointer handles for type: [16]byte
func ptrFromHandle_Array_16_byte(h CGoHandle) *[16]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[16]byte")
	if p == nil {
		return nil
	}
	return p.(*[16]byte)
}
func deptrFromHandle_Array_16_byte(h CGoHandle) [16]byte {
	p := ptrFromHandle_Array_16_byte(h)
	return *p
}
func handleFromPtr_Array_16_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[16]byte", p))
}

// --- wrapping slice: [16]byte ---
//
//export Array_16_byte_CTor
func Array_16_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_16_byte(&[16]byte{}))
}

//export Array_16_byte_len
func Array_16_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_16_byte(handle))
}

//export Array_16_byte_elem
func Array_16_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Array_16_byte(handle)
	return C.char(s[_idx])
}

//export Array_16_byte_set
func Array_16_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Array_16_byte(handle)
	s[_idx] = byte(_vl)
}

// Converters for implicit pointer handles for type: [4]byte
func ptrFromHandle_Array_4_byte(h CGoHandle) *[4]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4]byte")
	if p == nil {
		return nil
	}
	return p.(*[4]byte)
}
func deptrFromHandle_Array_4_byte(h CGoHandle) [4]byte {
	p := ptrFromHandle_Array_4_byte(h)
	return *p
}
func handleFromPtr_Array_4_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4]byte", p))
}

// --- wrapping slice: [4]byte ---
//
//export Array_4_byte_CTor
func Array_4_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_byte(&[4]byte{}))
}

//export Array_4_byte_len
func Array_4_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_byte(handle))
}

//export Array_4_byte_elem
func Array_4_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Array_4_byte(handle)
	return C.char(s[_idx])
}

//export Array_4_byte_set
func Array_4_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Array_4_byte(handle)
	s[_idx] = byte(_vl)
}

// Converters for implicit pointer handles for type: []stun.Checker
func ptrFromHandle_Slice_stun_Checker(h CGoHandle) *[]stun.Checker {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]stun.Checker")
	if p == nil {
		return nil
	}
	return p.(*[]stun.Checker)
}
func deptrFromHandle_Slice_stun_Checker(h CGoHandle) []stun.Checker {
	p := ptrFromHandle_Slice_stun_Checker(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_stun_Checker(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]stun.Checker", p))
}

// --- wrapping slice: []stun.Checker ---
//
//export Slice_stun_Checker_CTor
func Slice_stun_Checker_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_stun_Checker(&[]stun.Checker{}))
}

//export Slice_stun_Checker_len
func Slice_stun_Checker_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_stun_Checker(handle))
}

//export Slice_stun_Checker_elem
func Slice_stun_Checker_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Checker(handle)
	return handleFromPtr_stun_Checker(s[_idx])
}

//export Slice_stun_Checker_subslice
func Slice_stun_Checker_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Checker(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_stun_Checker(&ss))
}

//export Slice_stun_Checker_set
func Slice_stun_Checker_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_stun_Checker(handle)
	s[_idx] = ptrFromHandle_stun_Checker(_vl)
}

//export Slice_stun_Checker_append
func Slice_stun_Checker_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_stun_Checker(handle)
	*s = append(*s, ptrFromHandle_stun_Checker(_vl))
}

// Converters for implicit pointer handles for type: []stun.Getter
func ptrFromHandle_Slice_stun_Getter(h CGoHandle) *[]stun.Getter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]stun.Getter")
	if p == nil {
		return nil
	}
	return p.(*[]stun.Getter)
}
func deptrFromHandle_Slice_stun_Getter(h CGoHandle) []stun.Getter {
	p := ptrFromHandle_Slice_stun_Getter(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_stun_Getter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]stun.Getter", p))
}

// --- wrapping slice: []stun.Getter ---
//
//export Slice_stun_Getter_CTor
func Slice_stun_Getter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_stun_Getter(&[]stun.Getter{}))
}

//export Slice_stun_Getter_len
func Slice_stun_Getter_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_stun_Getter(handle))
}

//export Slice_stun_Getter_elem
func Slice_stun_Getter_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Getter(handle)
	return handleFromPtr_stun_Getter(s[_idx])
}

//export Slice_stun_Getter_subslice
func Slice_stun_Getter_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Getter(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_stun_Getter(&ss))
}

//export Slice_stun_Getter_set
func Slice_stun_Getter_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_stun_Getter(handle)
	s[_idx] = ptrFromHandle_stun_Getter(_vl)
}

//export Slice_stun_Getter_append
func Slice_stun_Getter_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_stun_Getter(handle)
	*s = append(*s, ptrFromHandle_stun_Getter(_vl))
}

// Converters for implicit pointer handles for type: []stun.Setter
func ptrFromHandle_Slice_stun_Setter(h CGoHandle) *[]stun.Setter {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]stun.Setter")
	if p == nil {
		return nil
	}
	return p.(*[]stun.Setter)
}
func deptrFromHandle_Slice_stun_Setter(h CGoHandle) []stun.Setter {
	p := ptrFromHandle_Slice_stun_Setter(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_stun_Setter(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]stun.Setter", p))
}

// --- wrapping slice: []stun.Setter ---
//
//export Slice_stun_Setter_CTor
func Slice_stun_Setter_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_stun_Setter(&[]stun.Setter{}))
}

//export Slice_stun_Setter_len
func Slice_stun_Setter_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_stun_Setter(handle))
}

//export Slice_stun_Setter_elem
func Slice_stun_Setter_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Setter(handle)
	return handleFromPtr_stun_Setter(s[_idx])
}

//export Slice_stun_Setter_subslice
func Slice_stun_Setter_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_stun_Setter(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_stun_Setter(&ss))
}

//export Slice_stun_Setter_set
func Slice_stun_Setter_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_stun_Setter(handle)
	s[_idx] = ptrFromHandle_stun_Setter(_vl)
}

//export Slice_stun_Setter_append
func Slice_stun_Setter_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_stun_Setter(handle)
	*s = append(*s, ptrFromHandle_stun_Setter(_vl))
}

// Converters for implicit pointer handles for type: []turn.ListenerConfig
func ptrFromHandle_Slice_turn_ListenerConfig(h CGoHandle) *[]turn.ListenerConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]turn.ListenerConfig")
	if p == nil {
		return nil
	}
	return p.(*[]turn.ListenerConfig)
}
func deptrFromHandle_Slice_turn_ListenerConfig(h CGoHandle) []turn.ListenerConfig {
	p := ptrFromHandle_Slice_turn_ListenerConfig(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_turn_ListenerConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]turn.ListenerConfig", p))
}

// --- wrapping slice: []turn.ListenerConfig ---
//
//export Slice_turn_ListenerConfig_CTor
func Slice_turn_ListenerConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_turn_ListenerConfig(&[]turn.ListenerConfig{}))
}

//export Slice_turn_ListenerConfig_len
func Slice_turn_ListenerConfig_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_turn_ListenerConfig(handle))
}

//export Slice_turn_ListenerConfig_elem
func Slice_turn_ListenerConfig_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_turn_ListenerConfig(handle)
	return handleFromPtr_turn_ListenerConfig(&(s[_idx]))
}

//export Slice_turn_ListenerConfig_subslice
func Slice_turn_ListenerConfig_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_turn_ListenerConfig(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_turn_ListenerConfig(&ss))
}

//export Slice_turn_ListenerConfig_set
func Slice_turn_ListenerConfig_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_turn_ListenerConfig(handle)
	s[_idx] = *ptrFromHandle_turn_ListenerConfig(_vl)
}

//export Slice_turn_ListenerConfig_append
func Slice_turn_ListenerConfig_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_turn_ListenerConfig(handle)
	*s = append(*s, *ptrFromHandle_turn_ListenerConfig(_vl))
}

// Converters for implicit pointer handles for type: []turn.PacketConnConfig
func ptrFromHandle_Slice_turn_PacketConnConfig(h CGoHandle) *[]turn.PacketConnConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]turn.PacketConnConfig")
	if p == nil {
		return nil
	}
	return p.(*[]turn.PacketConnConfig)
}
func deptrFromHandle_Slice_turn_PacketConnConfig(h CGoHandle) []turn.PacketConnConfig {
	p := ptrFromHandle_Slice_turn_PacketConnConfig(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_turn_PacketConnConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]turn.PacketConnConfig", p))
}

// --- wrapping slice: []turn.PacketConnConfig ---
//
//export Slice_turn_PacketConnConfig_CTor
func Slice_turn_PacketConnConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_turn_PacketConnConfig(&[]turn.PacketConnConfig{}))
}

//export Slice_turn_PacketConnConfig_len
func Slice_turn_PacketConnConfig_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_turn_PacketConnConfig(handle))
}

//export Slice_turn_PacketConnConfig_elem
func Slice_turn_PacketConnConfig_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_turn_PacketConnConfig(handle)
	return handleFromPtr_turn_PacketConnConfig(&(s[_idx]))
}

//export Slice_turn_PacketConnConfig_subslice
func Slice_turn_PacketConnConfig_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_turn_PacketConnConfig(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_turn_PacketConnConfig(&ss))
}

//export Slice_turn_PacketConnConfig_set
func Slice_turn_PacketConnConfig_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_turn_PacketConnConfig(handle)
	s[_idx] = *ptrFromHandle_turn_PacketConnConfig(_vl)
}

//export Slice_turn_PacketConnConfig_append
func Slice_turn_PacketConnConfig_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_turn_PacketConnConfig(handle)
	*s = append(*s, *ptrFromHandle_turn_PacketConnConfig(_vl))
}

// Converters for implicit pointer handles for type: []net.Addr
func ptrFromHandle_Slice_net_Addr(h CGoHandle) *[]net.Addr {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]net.Addr")
	if p == nil {
		return nil
	}
	return p.(*[]net.Addr)
}
func deptrFromHandle_Slice_net_Addr(h CGoHandle) []net.Addr {
	p := ptrFromHandle_Slice_net_Addr(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_net_Addr(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]net.Addr", p))
}

// --- wrapping slice: []net.Addr ---
//
//export Slice_net_Addr_CTor
func Slice_net_Addr_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_net_Addr(&[]net.Addr{}))
}

//export Slice_net_Addr_len
func Slice_net_Addr_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_net_Addr(handle))
}

//export Slice_net_Addr_elem
func Slice_net_Addr_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_net_Addr(handle)
	return handleFromPtr_net_Addr(s[_idx])
}

//export Slice_net_Addr_subslice
func Slice_net_Addr_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_net_Addr(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_net_Addr(&ss))
}

//export Slice_net_Addr_set
func Slice_net_Addr_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_net_Addr(handle)
	s[_idx] = ptrFromHandle_net_Addr(_vl)
}

//export Slice_net_Addr_append
func Slice_net_Addr_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_net_Addr(handle)
	*s = append(*s, ptrFromHandle_net_Addr(_vl))
}

// Converters for non-pointer handles for type: turn.Client
func ptrFromHandle_turn_Client(h CGoHandle) *turn.Client {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.Client")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.Client{})).(*turn.Client)
}
func handleFromPtr_turn_Client(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.Client", p))
}

// Converters for non-pointer handles for type: turn.ClientConfig
func ptrFromHandle_turn_ClientConfig(h CGoHandle) *turn.ClientConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.ClientConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ClientConfig{})).(*turn.ClientConfig)
}
func handleFromPtr_turn_ClientConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.ClientConfig", p))
}

// Converters for non-pointer handles for type: turn.ListenerConfig
func ptrFromHandle_turn_ListenerConfig(h CGoHandle) *turn.ListenerConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.ListenerConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ListenerConfig{})).(*turn.ListenerConfig)
}
func handleFromPtr_turn_ListenerConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.ListenerConfig", p))
}

// Converters for non-pointer handles for type: turn.PacketConnConfig
func ptrFromHandle_turn_PacketConnConfig(h CGoHandle) *turn.PacketConnConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.PacketConnConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.PacketConnConfig{})).(*turn.PacketConnConfig)
}
func handleFromPtr_turn_PacketConnConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.PacketConnConfig", p))
}

// Converters for non-pointer handles for type: turn.RecievedPacket
func ptrFromHandle_turn_RecievedPacket(h CGoHandle) *turn.RecievedPacket {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.RecievedPacket")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RecievedPacket{})).(*turn.RecievedPacket)
}
func handleFromPtr_turn_RecievedPacket(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.RecievedPacket", p))
}

// Converters for pointer handles for type: turn.RelayAddressGenerator
func ptrFromHandle_turn_RelayAddressGenerator(h CGoHandle) turn.RelayAddressGenerator {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.RelayAddressGenerator")
	if p == nil {
		return nil
	}
	return p.(turn.RelayAddressGenerator)
}
func handleFromPtr_turn_RelayAddressGenerator(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.RelayAddressGenerator", p))
}

// Converters for non-pointer handles for type: turn.RelayAddressGeneratorNone
func ptrFromHandle_turn_RelayAddressGeneratorNone(h CGoHandle) *turn.RelayAddressGeneratorNone {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.RelayAddressGeneratorNone")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorNone{})).(*turn.RelayAddressGeneratorNone)
}
func handleFromPtr_turn_RelayAddressGeneratorNone(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.RelayAddressGeneratorNone", p))
}

// Converters for non-pointer handles for type: turn.RelayAddressGeneratorPortRange
func ptrFromHandle_turn_RelayAddressGeneratorPortRange(h CGoHandle) *turn.RelayAddressGeneratorPortRange {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.RelayAddressGeneratorPortRange")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorPortRange{})).(*turn.RelayAddressGeneratorPortRange)
}
func handleFromPtr_turn_RelayAddressGeneratorPortRange(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.RelayAddressGeneratorPortRange", p))
}

// Converters for non-pointer handles for type: turn.RelayAddressGeneratorStatic
func ptrFromHandle_turn_RelayAddressGeneratorStatic(h CGoHandle) *turn.RelayAddressGeneratorStatic {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.RelayAddressGeneratorStatic")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.RelayAddressGeneratorStatic{})).(*turn.RelayAddressGeneratorStatic)
}
func handleFromPtr_turn_RelayAddressGeneratorStatic(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.RelayAddressGeneratorStatic", p))
}

// Converters for non-pointer handles for type: turn.STUNConn
func ptrFromHandle_turn_STUNConn(h CGoHandle) *turn.STUNConn {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.STUNConn")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn)
}
func handleFromPtr_turn_STUNConn(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.STUNConn", p))
}

// Converters for non-pointer handles for type: turn.Server
func ptrFromHandle_turn_Server(h CGoHandle) *turn.Server {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.Server")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.Server{})).(*turn.Server)
}
func handleFromPtr_turn_Server(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.Server", p))
}

// Converters for non-pointer handles for type: turn.ServerConfig
func ptrFromHandle_turn_ServerConfig(h CGoHandle) *turn.ServerConfig {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "turn.ServerConfig")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(turn.ServerConfig{})).(*turn.ServerConfig)
}
func handleFromPtr_turn_ServerConfig(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("turn.ServerConfig", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

//export turn_RelayAddressGenerator_Validate
func turn_RelayAddressGenerator_Validate(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "turn.RelayAddressGenerator")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = vifc.(turn.RelayAddressGenerator).Validate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Structs ---

// --- wrapping struct: turn.Client ---
//
//export turn_Client_CTor
func turn_Client_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_Client(&turn.Client{}))
}

//export turn_Client_TURNServerAddr
func turn_Client_TURNServerAddr(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_net_Addr(nil)
	}
	return handleFromPtr_net_Addr(gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).TURNServerAddr())

}

//export turn_Client_STUNServerAddr
func turn_Client_STUNServerAddr(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_net_Addr(nil)
	}
	return handleFromPtr_net_Addr(gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).STUNServerAddr())

}

//export turn_Client_Username
func turn_Client_Username(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_stun_Username(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Username()

	return handleFromPtr_stun_Username(&cret)
}

//export turn_Client_Realm
func turn_Client_Realm(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_stun_Realm(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Realm()

	return handleFromPtr_stun_Realm(&cret)
}

//export turn_Client_WriteTo
func turn_Client_WriteTo(_handle CGoHandle, data CGoHandle, to CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).WriteTo(deptrFromHandle_Slice_byte(data), ptrFromHandle_net_Addr(to))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export turn_Client_Listen
func turn_Client_Listen(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Listen()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_Client_Close
func turn_Client_Close(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Close()
	}
}

//export turn_Client_SendBindingRequestTo
func turn_Client_SendBindingRequestTo(_handle CGoHandle, to CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_net_Addr(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).SendBindingRequestTo(ptrFromHandle_net_Addr(to))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_net_Addr(nil)
	}
	return handleFromPtr_net_Addr(cret)
}

//export turn_Client_SendBindingRequest
func turn_Client_SendBindingRequest(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_net_Addr(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).SendBindingRequest()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_net_Addr(nil)
	}
	return handleFromPtr_net_Addr(cret)
}

//export turn_Client_Allocate
func turn_Client_Allocate(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_net_PacketConn(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).Allocate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_net_PacketConn(nil)
	}
	return handleFromPtr_net_PacketConn(cret)
}

//export turn_Client_AllocateTCP
func turn_Client_AllocateTCP(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_Ptr_client_TCPAllocation(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).AllocateTCP()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_client_TCPAllocation(nil)
	}
	return handleFromPtr_Ptr_client_TCPAllocation(cret)
}

//export turn_Client_CreatePermission
func turn_Client_CreatePermission(_handle CGoHandle, addrs CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).CreatePermission(deptrFromHandle_Slice_net_Addr(addrs)...)

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_Client_PerformTransaction
func turn_Client_PerformTransaction(_handle CGoHandle, msg CGoHandle, to CGoHandle, ignoreResult C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return handleFromPtr_client_TransactionResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).PerformTransaction(ptrFromHandle_Ptr_stun_Message(msg), ptrFromHandle_net_Addr(to), boolPyToGo(ignoreResult))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_client_TransactionResult(nil)
	}
	return handleFromPtr_client_TransactionResult(&cret)
}

//export turn_Client_OnDeallocated
func turn_Client_OnDeallocated(_handle CGoHandle, arg_0 CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).OnDeallocated(ptrFromHandle_net_Addr(arg_0))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).OnDeallocated(ptrFromHandle_net_Addr(arg_0))
	}
}

//export turn_Client_HandleInbound
func turn_Client_HandleInbound(_handle CGoHandle, data CGoHandle, myfrom CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Client")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.Client{})).(*turn.Client).HandleInbound(deptrFromHandle_Slice_byte(data), ptrFromHandle_net_Addr(myfrom))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

// --- wrapping struct: turn.ListenerConfig ---
//
//export turn_ListenerConfig_CTor
func turn_ListenerConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_ListenerConfig(&turn.ListenerConfig{}))
}

//export turn_ListenerConfig_Listener_Get
func turn_ListenerConfig_Listener_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ListenerConfig(handle)
	return handleFromPtr_net_Listener(op.Listener)
}

//export turn_ListenerConfig_Listener_Set
func turn_ListenerConfig_Listener_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ListenerConfig(handle)
	op.Listener = ptrFromHandle_net_Listener(val)
}

//export turn_ListenerConfig_RelayAddressGenerator_Get
func turn_ListenerConfig_RelayAddressGenerator_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ListenerConfig(handle)
	return handleFromPtr_turn_RelayAddressGenerator(op.RelayAddressGenerator)
}

//export turn_ListenerConfig_RelayAddressGenerator_Set
func turn_ListenerConfig_RelayAddressGenerator_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ListenerConfig(handle)
	op.RelayAddressGenerator = ptrFromHandle_turn_RelayAddressGenerator(val)
}

// --- wrapping struct: turn.PacketConnConfig ---
//
//export turn_PacketConnConfig_CTor
func turn_PacketConnConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_PacketConnConfig(&turn.PacketConnConfig{}))
}

//export turn_PacketConnConfig_PacketConn_Get
func turn_PacketConnConfig_PacketConn_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_PacketConnConfig(handle)
	return handleFromPtr_net_PacketConn(op.PacketConn)
}

//export turn_PacketConnConfig_PacketConn_Set
func turn_PacketConnConfig_PacketConn_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_PacketConnConfig(handle)
	op.PacketConn = ptrFromHandle_net_PacketConn(val)
}

//export turn_PacketConnConfig_RelayAddressGenerator_Get
func turn_PacketConnConfig_RelayAddressGenerator_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_PacketConnConfig(handle)
	return handleFromPtr_turn_RelayAddressGenerator(op.RelayAddressGenerator)
}

//export turn_PacketConnConfig_RelayAddressGenerator_Set
func turn_PacketConnConfig_RelayAddressGenerator_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_PacketConnConfig(handle)
	op.RelayAddressGenerator = ptrFromHandle_turn_RelayAddressGenerator(val)
}

// --- wrapping struct: turn.RelayAddressGeneratorStatic ---
//
//export turn_RelayAddressGeneratorStatic_CTor
func turn_RelayAddressGeneratorStatic_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_RelayAddressGeneratorStatic(&turn.RelayAddressGeneratorStatic{}))
}

//export turn_RelayAddressGeneratorStatic_RelayAddress_Get
func turn_RelayAddressGeneratorStatic_RelayAddress_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	return handleFromPtr_net_IP(&op.RelayAddress)
}

//export turn_RelayAddressGeneratorStatic_RelayAddress_Set
func turn_RelayAddressGeneratorStatic_RelayAddress_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	op.RelayAddress = deptrFromHandle_net_IP(val)
}

//export turn_RelayAddressGeneratorStatic_Address_Get
func turn_RelayAddressGeneratorStatic_Address_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	return C.CString(op.Address)
}

//export turn_RelayAddressGeneratorStatic_Address_Set
func turn_RelayAddressGeneratorStatic_Address_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	op.Address = C.GoString(val)
}

//export turn_RelayAddressGeneratorStatic_Net_Get
func turn_RelayAddressGeneratorStatic_Net_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	return handleFromPtr_transport_Net(op.Net)
}

//export turn_RelayAddressGeneratorStatic_Net_Set
func turn_RelayAddressGeneratorStatic_Net_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorStatic(handle)
	op.Net = ptrFromHandle_transport_Net(val)
}

//export turn_RelayAddressGeneratorStatic_Validate
func turn_RelayAddressGeneratorStatic_Validate(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.RelayAddressGeneratorStatic")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.RelayAddressGeneratorStatic{})).(*turn.RelayAddressGeneratorStatic).Validate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: turn.STUNConn ---
//
//export turn_STUNConn_CTor
func turn_STUNConn_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_STUNConn(&turn.STUNConn{}))
}

//export turn_STUNConn_WriteTo
func turn_STUNConn_WriteTo(_handle CGoHandle, p CGoHandle, q CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return C.longlong(0)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).WriteTo(deptrFromHandle_Slice_byte(p), ptrFromHandle_net_Addr(q))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export turn_STUNConn_Close
func turn_STUNConn_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_STUNConn_LocalAddr
func turn_STUNConn_LocalAddr(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return handleFromPtr_net_Addr(nil)
	}
	return handleFromPtr_net_Addr(gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).LocalAddr())

}

//export turn_STUNConn_SetDeadline
func turn_STUNConn_SetDeadline(_handle CGoHandle, t CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).SetDeadline(*ptrFromHandle_time_Time(t))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_STUNConn_SetReadDeadline
func turn_STUNConn_SetReadDeadline(_handle CGoHandle, t CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).SetReadDeadline(*ptrFromHandle_time_Time(t))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_STUNConn_SetWriteDeadline
func turn_STUNConn_SetWriteDeadline(_handle CGoHandle, t CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.STUNConn")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.STUNConn{})).(*turn.STUNConn).SetWriteDeadline(*ptrFromHandle_time_Time(t))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: turn.ClientConfig ---
//
//export turn_ClientConfig_CTor
func turn_ClientConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_ClientConfig(&turn.ClientConfig{}))
}

//export turn_ClientConfig_STUNServerAddr_Get
func turn_ClientConfig_STUNServerAddr_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.STUNServerAddr)
}

//export turn_ClientConfig_STUNServerAddr_Set
func turn_ClientConfig_STUNServerAddr_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.STUNServerAddr = C.GoString(val)
}

//export turn_ClientConfig_TURNServerAddr_Get
func turn_ClientConfig_TURNServerAddr_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.TURNServerAddr)
}

//export turn_ClientConfig_TURNServerAddr_Set
func turn_ClientConfig_TURNServerAddr_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.TURNServerAddr = C.GoString(val)
}

//export turn_ClientConfig_Username_Get
func turn_ClientConfig_Username_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.Username)
}

//export turn_ClientConfig_Username_Set
func turn_ClientConfig_Username_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Username = C.GoString(val)
}

//export turn_ClientConfig_Password_Get
func turn_ClientConfig_Password_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.Password)
}

//export turn_ClientConfig_Password_Set
func turn_ClientConfig_Password_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Password = C.GoString(val)
}

//export turn_ClientConfig_Realm_Get
func turn_ClientConfig_Realm_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.Realm)
}

//export turn_ClientConfig_Realm_Set
func turn_ClientConfig_Realm_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Realm = C.GoString(val)
}

//export turn_ClientConfig_Software_Get
func turn_ClientConfig_Software_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.CString(op.Software)
}

//export turn_ClientConfig_Software_Set
func turn_ClientConfig_Software_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Software = C.GoString(val)
}

//export turn_ClientConfig_RTO_Get
func turn_ClientConfig_RTO_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return C.longlong(int64(op.RTO))
}

//export turn_ClientConfig_RTO_Set
func turn_ClientConfig_RTO_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.RTO = time.Duration(int64(val))
}

//export turn_ClientConfig_Conn_Get
func turn_ClientConfig_Conn_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return handleFromPtr_net_PacketConn(op.Conn)
}

//export turn_ClientConfig_Conn_Set
func turn_ClientConfig_Conn_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Conn = ptrFromHandle_net_PacketConn(val)
}

//export turn_ClientConfig_Net_Get
func turn_ClientConfig_Net_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return handleFromPtr_transport_Net(op.Net)
}

//export turn_ClientConfig_Net_Set
func turn_ClientConfig_Net_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.Net = ptrFromHandle_transport_Net(val)
}

//export turn_ClientConfig_LoggerFactory_Get
func turn_ClientConfig_LoggerFactory_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ClientConfig(handle)
	return handleFromPtr_logging_LoggerFactory(op.LoggerFactory)
}

//export turn_ClientConfig_LoggerFactory_Set
func turn_ClientConfig_LoggerFactory_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ClientConfig(handle)
	op.LoggerFactory = ptrFromHandle_logging_LoggerFactory(val)
}

// --- wrapping struct: turn.RecievedPacket ---
//
//export turn_RecievedPacket_CTor
func turn_RecievedPacket_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_RecievedPacket(&turn.RecievedPacket{}))
}

//export turn_RecievedPacket_N_Get
func turn_RecievedPacket_N_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_turn_RecievedPacket(handle)
	return C.longlong(op.N)
}

//export turn_RecievedPacket_N_Set
func turn_RecievedPacket_N_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_turn_RecievedPacket(handle)
	op.N = int(val)
}

//export turn_RecievedPacket_Addr_Get
func turn_RecievedPacket_Addr_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RecievedPacket(handle)
	return handleFromPtr_net_Addr(op.Addr)
}

//export turn_RecievedPacket_Addr_Set
func turn_RecievedPacket_Addr_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RecievedPacket(handle)
	op.Addr = ptrFromHandle_net_Addr(val)
}

// --- wrapping struct: turn.RelayAddressGeneratorNone ---
//
//export turn_RelayAddressGeneratorNone_CTor
func turn_RelayAddressGeneratorNone_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_RelayAddressGeneratorNone(&turn.RelayAddressGeneratorNone{}))
}

//export turn_RelayAddressGeneratorNone_Address_Get
func turn_RelayAddressGeneratorNone_Address_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_RelayAddressGeneratorNone(handle)
	return C.CString(op.Address)
}

//export turn_RelayAddressGeneratorNone_Address_Set
func turn_RelayAddressGeneratorNone_Address_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_RelayAddressGeneratorNone(handle)
	op.Address = C.GoString(val)
}

//export turn_RelayAddressGeneratorNone_Net_Get
func turn_RelayAddressGeneratorNone_Net_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorNone(handle)
	return handleFromPtr_transport_Net(op.Net)
}

//export turn_RelayAddressGeneratorNone_Net_Set
func turn_RelayAddressGeneratorNone_Net_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorNone(handle)
	op.Net = ptrFromHandle_transport_Net(val)
}

//export turn_RelayAddressGeneratorNone_Validate
func turn_RelayAddressGeneratorNone_Validate(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.RelayAddressGeneratorNone")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.RelayAddressGeneratorNone{})).(*turn.RelayAddressGeneratorNone).Validate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: turn.RelayAddressGeneratorPortRange ---
//
//export turn_RelayAddressGeneratorPortRange_CTor
func turn_RelayAddressGeneratorPortRange_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_RelayAddressGeneratorPortRange(&turn.RelayAddressGeneratorPortRange{}))
}

//export turn_RelayAddressGeneratorPortRange_RelayAddress_Get
func turn_RelayAddressGeneratorPortRange_RelayAddress_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return handleFromPtr_net_IP(&op.RelayAddress)
}

//export turn_RelayAddressGeneratorPortRange_RelayAddress_Set
func turn_RelayAddressGeneratorPortRange_RelayAddress_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.RelayAddress = deptrFromHandle_net_IP(val)
}

//export turn_RelayAddressGeneratorPortRange_MinPort_Get
func turn_RelayAddressGeneratorPortRange_MinPort_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return C.ushort(op.MinPort)
}

//export turn_RelayAddressGeneratorPortRange_MinPort_Set
func turn_RelayAddressGeneratorPortRange_MinPort_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.MinPort = uint16(val)
}

//export turn_RelayAddressGeneratorPortRange_MaxPort_Get
func turn_RelayAddressGeneratorPortRange_MaxPort_Get(handle CGoHandle) C.ushort {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return C.ushort(op.MaxPort)
}

//export turn_RelayAddressGeneratorPortRange_MaxPort_Set
func turn_RelayAddressGeneratorPortRange_MaxPort_Set(handle CGoHandle, val C.ushort) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.MaxPort = uint16(val)
}

//export turn_RelayAddressGeneratorPortRange_MaxRetries_Get
func turn_RelayAddressGeneratorPortRange_MaxRetries_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return C.longlong(op.MaxRetries)
}

//export turn_RelayAddressGeneratorPortRange_MaxRetries_Set
func turn_RelayAddressGeneratorPortRange_MaxRetries_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.MaxRetries = int(val)
}

//export turn_RelayAddressGeneratorPortRange_Rand_Get
func turn_RelayAddressGeneratorPortRange_Rand_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return handleFromPtr_randutil_MathRandomGenerator(op.Rand)
}

//export turn_RelayAddressGeneratorPortRange_Rand_Set
func turn_RelayAddressGeneratorPortRange_Rand_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.Rand = ptrFromHandle_randutil_MathRandomGenerator(val)
}

//export turn_RelayAddressGeneratorPortRange_Address_Get
func turn_RelayAddressGeneratorPortRange_Address_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return C.CString(op.Address)
}

//export turn_RelayAddressGeneratorPortRange_Address_Set
func turn_RelayAddressGeneratorPortRange_Address_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.Address = C.GoString(val)
}

//export turn_RelayAddressGeneratorPortRange_Net_Get
func turn_RelayAddressGeneratorPortRange_Net_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	return handleFromPtr_transport_Net(op.Net)
}

//export turn_RelayAddressGeneratorPortRange_Net_Set
func turn_RelayAddressGeneratorPortRange_Net_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_RelayAddressGeneratorPortRange(handle)
	op.Net = ptrFromHandle_transport_Net(val)
}

//export turn_RelayAddressGeneratorPortRange_Validate
func turn_RelayAddressGeneratorPortRange_Validate(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.RelayAddressGeneratorPortRange")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.RelayAddressGeneratorPortRange{})).(*turn.RelayAddressGeneratorPortRange).Validate()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: turn.Server ---
//
//export turn_Server_CTor
func turn_Server_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_Server(&turn.Server{}))
}

//export turn_Server_AllocationCount
func turn_Server_AllocationCount(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Server")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(turn.Server{})).(*turn.Server).AllocationCount())

}

//export turn_Server_Close
func turn_Server_Close(_handle CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*turn.Server")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(turn.Server{})).(*turn.Server).Close()

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// --- wrapping struct: turn.ServerConfig ---
//
//export turn_ServerConfig_CTor
func turn_ServerConfig_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_turn_ServerConfig(&turn.ServerConfig{}))
}

//export turn_ServerConfig_PacketConnConfigs_Get
func turn_ServerConfig_PacketConnConfigs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return handleFromPtr_Slice_turn_PacketConnConfig(&op.PacketConnConfigs)
}

//export turn_ServerConfig_PacketConnConfigs_Set
func turn_ServerConfig_PacketConnConfigs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.PacketConnConfigs = deptrFromHandle_Slice_turn_PacketConnConfig(val)
}

//export turn_ServerConfig_ListenerConfigs_Get
func turn_ServerConfig_ListenerConfigs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return handleFromPtr_Slice_turn_ListenerConfig(&op.ListenerConfigs)
}

//export turn_ServerConfig_ListenerConfigs_Set
func turn_ServerConfig_ListenerConfigs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.ListenerConfigs = deptrFromHandle_Slice_turn_ListenerConfig(val)
}

//export turn_ServerConfig_LoggerFactory_Get
func turn_ServerConfig_LoggerFactory_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return handleFromPtr_logging_LoggerFactory(op.LoggerFactory)
}

//export turn_ServerConfig_LoggerFactory_Set
func turn_ServerConfig_LoggerFactory_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.LoggerFactory = ptrFromHandle_logging_LoggerFactory(val)
}

//export turn_ServerConfig_Realm_Get
func turn_ServerConfig_Realm_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return C.CString(op.Realm)
}

//export turn_ServerConfig_Realm_Set
func turn_ServerConfig_Realm_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.Realm = C.GoString(val)
}

//export turn_ServerConfig_ChannelBindTimeout_Get
func turn_ServerConfig_ChannelBindTimeout_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return C.longlong(int64(op.ChannelBindTimeout))
}

//export turn_ServerConfig_ChannelBindTimeout_Set
func turn_ServerConfig_ChannelBindTimeout_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.ChannelBindTimeout = time.Duration(int64(val))
}

//export turn_ServerConfig_InboundMTU_Get
func turn_ServerConfig_InboundMTU_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_turn_ServerConfig(handle)
	return C.longlong(op.InboundMTU)
}

//export turn_ServerConfig_InboundMTU_Set
func turn_ServerConfig_InboundMTU_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_turn_ServerConfig(handle)
	op.InboundMTU = int(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export turn_NewClient
func turn_NewClient(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NewClient(ptrFromHandle_Ptr_turn_ClientConfig(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_turn_Client(nil)
	}
	return handleFromPtr_Ptr_turn_Client(cret)
}

//export turn_NewSTUNConn
func turn_NewSTUNConn(nextConn CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_turn_STUNConn(turn.NewSTUNConn(ptrFromHandle_net_Conn(nextConn)))

}

//export turn_NetConnReadFrom
func turn_NetConnReadFrom(conn CGoHandle, p CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NetConnReadFrom(ptrFromHandle_net_PacketConn(conn), deptrFromHandle_Slice_byte(p))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_turn_RecievedPacket(nil)
	}
	return handleFromPtr_turn_RecievedPacket(&cret)
}

//export turn_NewServer
func turn_NewServer(config CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NewServer(*ptrFromHandle_turn_ServerConfig(config))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_turn_Server(nil)
	}
	return handleFromPtr_Ptr_turn_Server(cret)
}

// ---- Functions ---

//export turn_NetAddrString
func turn_NetAddrString(addr CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return C.CString(turn.NetAddrString(ptrFromHandle_net_Addr(addr)))

}

//export turn_NetConnWriteTo
func turn_NetConnWriteTo(conn CGoHandle, p CGoHandle, addr CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NetConnWriteTo(ptrFromHandle_net_PacketConn(conn), deptrFromHandle_Slice_byte(p), ptrFromHandle_net_Addr(addr))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.longlong(0)
	}
	return C.longlong(cret)
}

//export turn_NetResolveUDPAddr
func turn_NetResolveUDPAddr(network *C.char, address *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NetResolveUDPAddr(C.GoString(network), C.GoString(address))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_net_UDPAddr(nil)
	}
	return handleFromPtr_net_UDPAddr(&cret)
}

//export turn_GenerateAuthKey
func turn_GenerateAuthKey(username *C.char, realm *C.char, password *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := turn.GenerateAuthKey(C.GoString(username), C.GoString(realm), C.GoString(password))

	return handleFromPtr_Slice_byte(&cret)
}

//export turn_NetConnSetTimeout
func turn_NetConnSetTimeout(conn CGoHandle, sec C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = turn.NetConnSetTimeout(ptrFromHandle_net_PacketConn(conn), int(sec))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_DefaultPermissionHandler
func turn_DefaultPermissionHandler(arg_0 CGoHandle, arg_1 CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return boolGoToPy(turn.DefaultPermissionHandler(ptrFromHandle_net_Addr(arg_0), deptrFromHandle_net_IP(arg_1)))

}

//export turn_NetConnClose
func turn_NetConnClose(conn CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = turn.NetConnClose(ptrFromHandle_net_PacketConn(conn))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export turn_NetListenPacket
func turn_NetListenPacket(network *C.char, address *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	cret, __err := turn.NetListenPacket(C.GoString(network), C.GoString(address))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_net_PacketConn(nil)
	}
	return handleFromPtr_net_PacketConn(cret)
}

//export turn_NetConnGetLocalAddr
func turn_NetConnGetLocalAddr(conn CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_net_Addr(turn.NetConnGetLocalAddr(ptrFromHandle_net_PacketConn(conn)))

}

//export turn_NetUDPAddrChangePort
func turn_NetUDPAddrChangePort(addr CGoHandle, port C.longlong) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	var __err error
	__err = turn.NetUDPAddrChangePort(ptrFromHandle_net_Addr(addr), int(port))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}
